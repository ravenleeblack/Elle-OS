In Elle I want to rename some things. I told you this was an unusal os. Whats the point of building an os if you cant change things to the 
way you want and understand. This area is for explaining some things, as well as, present ideas or understanding.

core - replaces the name kernel. This isnt popcorn. Would like a core that allows us to remove and replace system modules that connect to core.
event/s - replaces process - An event is a program in execution.
thread/s - remains same - A thread begins or starts an event into execution and remains as it runs?

sequence/s - replaces the old event handling for mouse and keyboard. We would say mouse or keyboard input sequence/s or sequence handling. I had 
to change the name of this since event/s replace processes and it would be confusing as a whole if I left event for mouse and keyboard handling.
The main purpose of renaming alot of things in the os is to provide a better understanding of the os in a new way as a whole. 

lock_gate - replaces mutexes if used
guide/s - replace semaphores if used

passage - standard input and output
vine passage - replaces pipe - there will be an external and internal vine. Where the external vine is the communication between the server and the 
subserver while the internal vine is the communication between the subserver and the client.

raml - (ra-mule) - real address memory locations. This gives a more direct name to phyical addresses (ram). raml address, raml addresses
saml - (sam-mule) - standard address memory locations. This gives a more direct name to memory allocated by the cpu, the same memory that gets
paged to a frame address by address. 

vaml - (va-mule) - virtual address memory locations. This gives a more direct name for virtual addresses.
daml - (da-mule) - device address memory locations. Under normal circumstances this would still be phyical addresses or raml but in order to be
clear about what addresses we are using, we just use daml, when it comes to ring drives - hard and floppy drives. This helps prevent any confusion
when using vaml and when we get to the point where we moving pages between ram (raml) and hardware (daml).

When we are talking about paging saml to raml, we can say we are using the standard memory layout. If virtual memory is being used, then we are no longer
using the standard memory layout, and now using the extended memory layout. This helps clarify what part of memory is being worked on or the stage its at.
If we are implementing paging but have not yet added vaml then we are working on standard memory layout then when we get to the point of adding vaml then
we have started using the the extented memory layout. Least it provides a method to understand where we actually are.

sadule - (sa-dule) - standard address module. A sadule replaces the word page and has saml addresses. sadule directory, sadule_index, sadule, saml addresses.
These sadules with saml addresses get assigned to addules with raml addresses on a one to one basis.
addule - (ad-dule) - address module. replaces frames in phyical memory (ram). So we have addules that contain raml addresses.


When it comes to ui the desktop is a main frame and a program window is a sub frame. All other ui elements are elements.
main_frame - The main frame is the desktop. It has an empty or nulled parent. If support for multiple monitors later or virtual desktops then they become 
siblings to the main frame and not children. The main frame is a single instance and is the main frame or rect for everything else that needs to be shown 
or displayed in that particular monitor.
subframe -  A program window. It is also a child to the main frame or any one of the main frames sibling/s.
elements - elements can be either children to the main frame or to the sub frame.

In elle we have a frame manager. The frame manager manages the frames and its child elements along with the code behind and input sequences of those elements.

Archive Filing System (AFS) - an old library like filing system of cards. The roots are archives, directorys that are not roots are catalogs, and everything
else is a card. We would say that a file is a file card, binary is a module card, and devices are device cards that can be accessed. Every card has a index_tag
instead of a fd or handle. Every card has a label_index_tag which consists of card traits and not attributes.

If we have to get inspiration and ideas from the other os's then a more linux like filing system and terminal would be best for the afs and the terminal 
then a more windows like gui system for graphics. 

I would actually like to figure out how to make my own filing system so that I can use .elm files. (Executable Linked Modules). Where all lib and 
binary file cards are .mod file cards until they get linked into an .elm file card. The .elm module card is the executable program.


system units
While everything in the system is a card there are always alternative names for unit/s. Especially when it comes to abstract vs concrete.

Type                            Unit Type
data                            component/s
ui                              element/s
model                           object          //The only time the word object is used in elle is when refering to 3d models

file                            file card
binary                          module card
device                          device card


In a server/client enviroment: Its typically a chained enviroment where the real server is a server and the your os is the client but also a server
itself to user mode which is a client. Under this circumstance we would say that we have a server for the server, a subserver for your os, and user 
mode is a client. This will help clarify which part of the chain we are talking about when we have a server, sub-server, client work flow. The only 
change here is we are creating a new word for the middle so we are not directly saying either server or client for the middle when trying to explain
something in the work flow of everything. This helps eliminate confusion and we still know that the middle can be or is a server or a client. If there
is more then a 2 chain workflow then we ref the middle subservers as 1 and 2. server, subserver 1, subserver 2, client.


When it comes to hardware abstraction we look at it like a distribution hub or building where one side takes in importing/input and the other side sends 
out exporting/output. We connect up to docks, we send info into a dock and send info out thorugh the dock/s. 

Since we are using the word dock here, that means we can no longer use it for a ui docking system, so will have to come up with a new term like port 
system for ui or something along those lines.

If we have cards and cards will allow us to use devices, then this would be called a hard dock connection, and if we find a way to connect to software 
through a means of card, then it would be called a soft dock connection. Where we have a hardware interface hub and a software interface hub and we simply
connect to the proper dock for input and output. Furthurmore we treat all buses the same way. Where a connection to and from is a dock and it is just an 
interface hub to something else.

