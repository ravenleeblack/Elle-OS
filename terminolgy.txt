In Elle I want to rename some things. I told you this was an unusal os. Whats the point of building an os if you cant change things to the 
way you want and understand. This area is for explaining some things, as well as, present ideas or understanding.

core - replaces the name kernel. This isnt popcorn. Would like a core that allows us to remove and replace system modules that connect to core.
event/s - replaces process - An event is a program in execution.
thread/s - remains same - A thread begins or starts an event into execution and remains as it runs?

sequence/s - replaces the old event handling for mouse and keyboard. We would say mouse or keyboard input sequence/s or sequence handling. I had 
to change the name of this since event/s replace processes and it would be confusing as a whole if I left event for mouse and keyboard handling.
The main purpose of renaming alot of things in the os is to provide a better understanding of the os in a new way as a whole. Or try to provide a
better and simpler understanding at least.

lock_gate - replaces mutexes if used
guide/s - replace semaphores if used

request/s - replace the name irq - you request an interrrupt.
service/s - replaces name isr - the interrupt provides the service of what you requested.
interrupt hub - replaces the name pic - 

passage - standard input and output
vine passage - replaces pipe - there will be an external and internal vine. Where the external vine is the communication between the server and the 
subserver while the internal vine is the communication between the subserver and the client.

raml - (ra-mule) - real address memory locations. This gives a more direct name to phyical addresses (ram). raml address, raml addresses
saml - (sam-mule) - standard address memory locations. This gives a more direct name to memory allocated by the cpu, the same memory that gets
paged to a frame address by address. 

vaml - (va-mule) - virtual address memory locations. This gives a more direct name for virtual addresses.
daml - (da-mule) - device address memory locations. Under normal circumstances this would still be phyical addresses or raml but in order to be
clear about what addresses we are using, we just use daml, when it comes to ring drives - hard and floppy drives. This helps prevent any confusion
when using vaml and when we get to the point where we moving pages between ram (raml) and hardware (daml).

When we are talking about paging saml to raml, we can say we are using the standard memory layout. If virtual memory is being used, then we are no longer
using the standard memory layout, and now using the extended memory layout. This helps clarify what part of memory is being worked on or the stage its at.
If we are implementing paging but have not yet added vaml then we are working on standard memory layout then when we get to the point of adding vaml then
we have started using the the extended memory layout. Least it provides some method of understanding to know where we actually are.

sadule - (sa-dule) - standard address module. A sadule replaces the word page and has saml addresses. sadule directory, sadule_index, sadule, saml addresses.
These sadules with saml addresses get assigned to addules with raml addresses on a one to one basis.
addule - (ad-dule) - address module. replaces frames in phyical memory (ram). So we have addules that contain raml addresses.


When it comes to ui the desktop is a main frame and a program window is a sub frame. All other ui elements are elements.
main_frame - The main frame is the desktop. It has an empty or nulled parent. If support for multiple monitors later or virtual desktops then they become 
siblings to the main frame and not children. The main frame is a single instance and is the main frame or rect for everything else that needs to be shown 
or displayed in that particular monitor.
subframe -  A program window. It is also a child to the main frame or any one of the main frames sibling/s.
elements - elements can be either children to the main frame or to the sub frame.

In elle we have a frame manager. The frame manager manages the frames and its child elements along with the code behind and input sequences of 
those elements.

Archive Filing System (AFS) - an old library like filing system of cards. The roots are archives, directorys that are not roots are catalogs, 
and everything else is a card. We would say that a file is a file card, binary is a module card, and devices are device cards that can be 
accessed. Every card has a index_tag instead of a fd or handle. Every card has a label_index_tag which consists of card traits not attributes.

If we have to get inspiration and ideas from the other os's then a more linux like filing system and terminal would be best for the afs and the 
terminal then/and a more windows like gui system for the graphics side of things without all the heavy encapsulation. 

I would actually like to figure out how to make my own filing system so that I can use .elm files. (Executable Linked Modules). Where all lib and 
binary file cards are .mod file cards until they get linked into an .elm file card. The .elm module card is the executable program.


system units
While everything in the system is a card there are always alternative names for unit/s. Especially when it comes to abstract vs concrete.

Type                            Unit Type
data                            component/s
ui                              element/s
model                           object          //The only time the word object is used in elle is when refering to 3d models

file                            file card
binary                          module card
device                          device card


In a server/client enviroment: Its typically a chained enviroment where the real server is a server and the your os is the client but also a server
itself to user mode which is a client. Under this circumstance we would say that we have a server for the server, a subserver for your os, and user 
mode is a client. This will help clarify which part of the chain we are talking about when we have a server, sub-server, client work flow. The only 
change here is we are creating a new word for the middle so we are not directly saying either server or client for the middle when trying to explain
something in the work flow of everything. This helps eliminate confusion and we still know that the middle can be or is a server or a client. If there
is more then a 2 chain workflow then we ref the middle subservers as 1 and 2. server, subserver 1, subserver 2, client.


When it comes to hardware abstraction we look at it like a distribution hub or building where one side takes in importing/input and the other side sends 
out exporting/output. We connect up to docks, we send info into a dock and send info out through a dock/s. 

Since we are using the word dock here, that means we can no longer use it for a ui docking system, so will have to come up with a new term like port 
system for ui or something along those lines.

If we have cards and cards will allow us to use devices, then this would be called a hard dock connection, and if we find a way to connect to software 
through a means of card(system calls??), then it would be called a soft dock connection. Where we have a hardware interface hub and a software interface
hub and we simply connect to the proper dock for input and output. Furthurmore we treat all buses the same way. Where a connection to and from is a dock
and it is just an interface hub to something else.

At some point I will port my language Illeshian and compiler, if Elle ever gets to that point, so these are terms that come from that:
mark - char 
strand - string - a strand is a sequence of marks or chars
num - int - A whole number
deci - a float - a decimaled number
decii - double
deciii - double double
deciv - 4 doubles
hold - variable - hold is short for placeholder and thats all a variable is, a placeholder in saml memory, for some data.
table - array
pare - bool
tripare - new kind of bool
check - if - we check the expression or condition
else - else
compare - switch - we compare the expression or condition, to a line option, otherwise we do something else
line - case
other - default
loop - while - as long as the expression or condition is true we loop another iteration or cycle.
set - for loop - a set loop, sets a numbered amount of iterations or cycles, based on condition.
log - struct - stands for a datalog
list - enum
manager - first class function - no relation to oop classes only a heirachy reference to functions. The manager may allow all data tools into the 
manager except for other managers. You may write as many second class functions or data tools into the the first class function manager.
function - second class function - no relation to oop classes only a heirachy reference to functions. A function may allow all data tools into a 
function except for managers and other functions. I do not support closures.
call - calls a manager or function

data - data is just some kind of value.
data info - data info is the information about that data, it is not to be confused with data itself, because it does not contain any real value.
data types - data types are the available types the data could or can be.
data tools - data tools are the tools used to manipulate the data to do something.
data modifiers - data modifiers modify the data but are not really a data tool themselves. (more of a keyword tool).

You might see some refs to them. At this point they have become so second natured to me. Least I have provided some refs here so your not completly 
thrown off. I know some terminolgy up top seems weird but after a while you get use to them and they really do make alot more sense.
