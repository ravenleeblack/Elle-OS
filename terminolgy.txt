In Elle I want to rename some things. I told you this was an unusal os. Whats the point of building an os if you cant change things to the 
way you want and understand. This area is for explaining some things, as well as, present ideas or understanding.

core - replaces the name kernel. This isnt popcorn.
event - replaces process - A program in execution.
thread - remains same - A program that runs an event in execution.
sequence - replaces the old event for mouse and keyboard. We would say mouse or keyboard input sequence/s. Had to change this since I used 
event for processes and it would be confusing if left the same.

passage - standard input and output
vine passage - replaces pipe - there will be an external and internal vine.

raml - (ra-mule) - real address memory locations. This gives a more direct name to phyical addresses. raml address, raml addresses
saml - (sam-mule) - standard address memory locations. This gives a more direct name to memory allocated by the cpu, the same memory that gets
paged to a frame address by address. 

vaml - (va-mule) - virtual address memory locations. This gives a more direct name for virtual addresses.
daml - (da-mule) - device address memory locations. Under normal circumstances this would still be phyical addresses or raml but in order to be
clear about what addresses we are using, we just use daml, when it comes to ring drives - hard and floppy drives. This helps prevent any confusion
when using vaml and when we get to the point where we moving pages between ram (raml) and hardware (daml).

When we are talking about paging saml to raml, we say we are using the standard memory layout. If virtual memory is being used, then we are no longer
using the standard memory layout, and now using the extended memory layout.

sadule - (sa-dule) - standard address module. A sadule replaces the word page and has saml addresses. sadule directory, sadule_index, sadule, saml addresses
addule - (ad-dule) - address module. replaces frames in phyical memory. So we have addules that contain raml addresses.


When it comes to ui the desktop is a main frame and a program window is a sub frame. All other ui elements are elements.
main_frame - The main frame is the desktop. It has an empty or nulled parent. If support for multiple monitors later or virtual desktops then they become 
siblings to the main frame and not children.
subframe -  A program window. It is also a child to the main frame or the main frames sibling/s.
elements - elements can be either children to the main frame or to the sub frame.

In elle we have a frame manager. The frame manager manages the frames and its child elements along with the code behind and input sequences of those elements.

Archive Filing System (AFS) - an old library like filing system of cards. The roots are archives, directorys are catalogs, and everything else 
is a card. We would say that a file is a file card, binary is a module card, and devices are device cards that can be accessed.

If we have to get inspiration and ideas from the other os's then a more linux like filing system and terminal would be best for the afs and terminal 
then a more windows like gui system for graphics. 

I would actually like to figure out how to make my own filing system so that I can use .elm files. (Executable Linked Modules). Where all lib and 
binary file cards are .mod file cards until they get linked into an .elm file card.


system units
While everything in the system is a card there are always alternative names for unit/s. Especially when it comes to abstract vs concrete.

Type                            Unit Type
data                            component/s
ui                              element/s
model                           object          //The only time the word object is used in elle is when refering to 3d models

file                            file card
binary                          module card
device                          device card


In a server/client enviroment: Its typically a chained enviroment where the real server is a server and the your os is the client but also a server
itself to user mode which is a client. Under this circunstance we would say that we have a server for the server, a subserver for your os, and user 
mode is a client. This will help clarify which part of the chain we are talking about when we have a server, sub-server, client work flow. The only 
change here is we are creating a new word for the middle so we are not directly saying either server or client for the middle when trying to explain
something in the work flow of everything. This helps eliminate confusion and we still know that the middle can be or is a server or a client.


When it comes to hardware abstraction we look at it like a distribution hub or building where one side takes in importing/input and the other side sends 
out exporting/output. We connect up to docks, we send info into a dock and send info out thorugh the dock/s. 

Since we are using the word dock here, that means we can no longer use it for a ui docking system, so will have to come up with a new name like port 
system for ui or something along those lines.
